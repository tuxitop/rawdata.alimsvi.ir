---
title: ۵ نکته کاربردی در خط فرمان لینوکس
author: علی موسوی
date: 2016-06-01
tags: لینوکس, خط فرمان
description: معرفی چند دستور و نکتهٔ کاربردی مفید برای استفاده در خط فرمان لینوکس
mathjax: false
template: article.jade
noindex: false
---

خط فرمان لینوکس سرشار است از انواع و اقسام دستورات کاربردی که گاه و بی‌گاه ما 
را به ترمینال لینوکس می‌کشانند. شاید کمتر کاربری باشد که گذرش به خط فرمان و 
دستورات آن در لینوکس نیفتاده باشد و سعی نکرده باشد از روی اجبار یا حتی 
سرگرمی سر از کار برخی از این دستورات در آورد.

اما قابلیت‌های خط فرمان لینوکس تنها به دستورات کوچک و بزرگ و کاربردی و گاه
احمقانه آن ختم نمی‌شود. همان طور که می‌دانید bash به عنوان یک زبان 
اسکریپت‌نویسی و بستری برای اجرای این دستورات، قابلیت‌هایی دارد که می‌تواند 
تجربه ما را در محیط دوست‌داشتنی ترمینال لینوکس راحت‌تر کند.

در این مقاله من برخی از قابلیت‌هایی را که یادگیری آن‌ها برای من باعث استفاده 
سریع‌تر و حرفه‌ای‌تر از خط فرمان لینوکس شد را با شما به اشتراک خواهم گذاشت.

<span class="more"></span>

### ۱. هدایت خروجی (Output Redirection) ###

شاید تا به حال پیش آمده باشد که از دستور `find` برای جستجوی چیزی در پوشهٔ `/`
استفاده کنید. چیزی شبیه دستور زیر:

```bash
$ find / -name cups
```

اجرای این دستور توسط یک کاربر معمولی، بیش از آن که نتیجه‌ای به ما دهد، خطای
دسترسی به ما نشان خواهد داد. طبیعتا می‌توان با اجرای دستور توسط کاربر root 
از شر این خطاهای دسترسی راحت شد، اما همیشه دسترسی به کاربر root وجود ندارد و 
به جز آن، توصیه می‌شود که تا حد ممکن از کاربران عادی برای انجام دستورات 
استفاده شود.

برای حل این مشکل می‌توان از «هدایت خروجی» استفاده کرد. یک روش آن می‌تواند دستور
 زیر باشد:

```bash
$ find / -name cups > output.txt
```

با اجرای این دستور تنها چیزی که در صفحهٔ نمایش نشان داده خواهد شد، خطاهای
دسترسی هستند، و یافته‌ها به فایل `output.txt` هدایت خواهند شد. چرا که ما 
«خروجی استاندارد» دستور را به فایل `output.txt` منتقل کرده‌ایم و خروجی خطا
همچنان به صفحهٔ نمایش منتقل می‌گردد.

شاید بهتر باشد به جای هدایت خروجی استاندارد، خروجی خطا را دور بیاندازیم و 
خروجی استاندارد را در صفحهٔ نمایش چاپ کنیم. برای این کار می‌توانیم از دستور زیر
بهره ببریم:

```bash
$ find / -name cups 2> /dev/null
```

تنها تفاوت این دستور، با دستور پیشین عدد 2 است. عدد 2 معرف خروجی خطاست و ما با
این دستور خروجی خطا را به فایل ‭`/dev/null`‬ منتقل می‌کنیم. شاید نتیجه‌گیری
کنید که احتمالا عدد 1 نیز معرف خروجی استاندارد باشد، که نتیجه‌گیری کاملا درستی
است و در واقع دو دستور زیر هر دو خروجی استاندارد را منتقل خواهند کرد:
```bash
$ find / -name cups > output.txt
$ find / -name cups 1> output.txt
```

اما گاهی لازم است که هم خروجی استاندارد و هم خروجی خطا را به یک فایل منتقل 
کنید. چیزی شبیه دستور زیر:
```bash
$ find / -name cups > output.txt 2> output.txt
```

این دستور کاملا صحبح است، اما زمانی که نیاز داریم هم خروجی خطا و هم خروجی 
استاندارد را به یک فایل مشترک منتقل می‌کنیم، با روش بهتری می‌توان این دستور 
را کوتاه‌تر کرد:

```bash
$ find / -name cups > output.txt 2>&1
```

این دستور با استفاده ار کاراکتر & خروجی خطا را نیز به خروجی استاندارد منتقل 
می‌کند و در نتیجه، محتویات هر دو خروجی به فایل `output.txt` منتقل خواهد شد.


### ۲. بسط آکولاد (Brace Expansion) ###
از نظر من یکی از پر کاربردترین و بهترین ویژگی‌های bash «بسط آکولاد» یا به 
انگلیسی Brace Expansion است. با استفاده از این ویژگی می‌توان لیستی از 
رشته‌ها را به خط فرمان داد و آن‌ها را به صورت آرگومان‌های مجزا دریافت کرد. این 
لیست می‌بایست توسط کاراکترهای { و } بسته شده باشند. به عنوان مثال:
```bash
$ echo {one,two,three,four}
one two three four
```
استفاده از این ویژگی به این شکل شاید احمقانه به نظر بیاید، چرا که استفاده از 
آکولاد به جای اسپیس حتی بیشتر آزار دهنده است، اما کاربرد آن در واقع به این 
شکل نیست. بسط آکولاد زمانی مفید واقع می‌شود که ما رشته‌ای را درست قبل یا بعد 
از بسط آکولاد قرار دهیم:

```bash
$ echo {one,two,three,four}fish
onefish twofish threefish fourfish

$ echo fish{one,two,three,four}
fishone fishtwo fishthree fishfour

$ echo blue{one,two,three,four}fish
blueonefish bluetwofish bluethreefish bluefourfish
```
همان طور که مشاهده می‌کنید، بسط آکولاد رشته‌های قبل و بعد را به هر یک از 
رشته‌های داخل لیست متصل می‌کند. توجه کنید که هیچ فاصله‌ای بین ویرگول‌ها، 
آکولادها و ... وجود ندارد. چنانچه رشته ما به اسپیس ختم شود و یا با اسپیس 
شروع شود، می‌بایست آن را در "" محصور کنیم.

اما هنوز هم شاید استفاده از این ویژگی برایتان گنگ باشد. با استفاده از این 
ویژگی می‌توان به عنوان مثال تعدادی از بسته‌های python را به این شکل نصب کرد:

```bash
$ pacman -S python-{tzdata,dbus,cairo,xdg}
```

و یا برای کپی کردن یک فایل در یک مقصد دور:

```bash
$ cp /etc/httpd/conf/httpd.conf{,.back}
```

قطعا موارد کاربرد این ویژگی بسیار زیاد است و به مرور زمان با یادگیری این 
امکان مفید می‌توانید به صورت روزانه در دستورات زیادی از آن بهره ببرید.

### ۳. جایگزاری دستورات (Command Substitution) ###

یکی دیگر از ویژگی‌های کاربردی خط فرمان لینوکس امکان جایگزاری دستورات است. 
برای استفاده از این امکان کافی است دستور خود را در یک پرانتز محصور کرده و پیش
از پرانتر یک علامت $ قرار دهید:

```bash
$ today=$(date +%d-%b-%Y)
$ echo $today
01-Jun-2017
```
همان‌طور که در مثال مشاهده می‌کنید. خروجی دستور `date +%d-%b-%Y` در متغیر
`today` قرار داده شده است.
این ویژگی کاربرد بسیاری در نوشتن اسکریپت‌های bash دارد. از دیگر کاربردهای آن
می‌تواند استفاده از خروجی یک دستور به عنوان ورودی دستوری دیگر باشد. به عنوان
مثال دستور `pacman -Qtdq` در آرچ لینوکس، بسته‌هایی را که وابسته به هیچ
بستهٔ دیگری نیستند و به صورت دستی نیز نصب نشده‌اند لیست می‌کند. این بسته‌ها 
عموما بسته‌هایی هستند که قبلا به عنوان یک وابستگی نصب شده‌اند و دیگر نیازی 
به آن‌ها نیست. برای حذف آن‌ها می‌توان از دستور زیر استفاده نمود:

```bash
# pacman -Rns $(pacman -Qtdq)
```
### ۴. حلقه for ###
همان‌طور که گفته شد، bash یک زبان اسکریپ‌نویسی است و بسیاری از امکانات مفید 
زبان‌های مختلف برنامه‌نویسی را با خود به همراه دارد. از جمله حلقه‌های مختلف و
همچنین عبارات شرطی. یکی از این امکانات که می‌تواند در دستورات روزمره نیز 
استفاده شود حلقه for است. به عنوان مثال دستور زیر کلیه فایل‌های پوشهٔ جاری
را به فایلی با همان نام، و با پسوند ‭.bak‬ کپی می‌کند:

```bash
$ for file in *; do cp $file $file.bak; done
```

و همچنین دستور زیر کلیه فایل‌ها با پسوند avi یا mkv و یا mp4 را به پوشه‌ای
به نام `movies` منتقل می‌کند:

```bash
$ for file in *.{mp4,mkv,avi}; do mv $file movies/; done
```

### ۵. جستجوی برعکس در تاریخچه (Revese History Search) ###
آخرین ویژگی کاربردی bash که در این مطلب به آن خواهیم پرداخت، امکان «جستجوی
 برعکس در تاریخچه دستورات» است. با استفاده از این ویژگی می‌توان در تاریخچهٔ 
 دستوراتی که قبلا اجرا شده است، به دنبال دستوری گشت که رشته‌ای خاص در آن قرار
 دارد. پس از یافتن این دستور می‌توان آن را مستقیما اجرا نمود و یا ابتدا 
 ویرایش و سپس اجرایش کرد.
 
 برای استفاده از این ویژگی کافی است کلیدهای Ctrl و R را در محیط خط فرمان 
 لینوکس فشار دهید و رشته‌ی مد نظر خود را تایپ کنید. bash آخرین دستوری را که
 رشته مورد نظر شما در آن قرار داشته است، به شما نمایش خواهد داد و شما با 
 فشردن مجدد کلیدهای مذکور می‌توانید در تاریخچه دستورات به عقب بازگشته و 
 سایر دستوراتی که شامل رشته مورد نظر شماست را نیز مشاهده کنید. برای اجرای 
 هر یک از دستورات می‌توانید از کلید Enter استفاده کنید و یا برای ویرایش 
 آن‌ها از کلیدهای جهت‌نمای راست و یا چپ استفاده کنید.

این ویژگی شاید ساده‌ترین نکتهٔ این لیست باشد، اما قطعا یکی از پرکاربردترین‌ِ 
آن‌هاست.


### نتیجه‌گیری ###
همان‌طور که گفته شد، bash ویژگی‌های بسیاری دارد و حقه‌ها و نکته‌های زیادی را 
می‌توان از امکانات آن مثال زد. قطعا هر یک ما پس از مدتی استفاده از لینوکس 
و ویژگی‌های آن، با برخی از این ویژگی‌ها بیشتر آشنا شده و روز به روز به آن‌ها 
بیشتر عادت می‌کنید.

چنانچه شما هم نکاتی از این دست را می‌شناسید که فکر می‌کنید می‌تواند مفید واقع
شود و یا اسکریپت کاربردی‌ای با استفاده از ویژگی‌های bash نوشته‌اید، بسیار 
خوشحال خواهم شد اگر به نحوی آن را به اشتراک بگذارید.
